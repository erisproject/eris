From: Jason Rhinelander <jason@imaginary.ca>
Date: Tue, 3 Nov 2015 15:47:25 -0500
Subject: Replace std::is_base_of with boost::is_base_of

---
 eris/Member.hpp       |  7 ++++---
 eris/SharedMember.hpp |  5 +++--
 eris/Simulation.hpp   | 33 +++++++++++++++++----------------
 eris/algorithms.hpp   |  5 +++--
 4 files changed, 27 insertions(+), 23 deletions(-)

diff --git a/eris/Member.hpp b/eris/Member.hpp
index 1ad35b8..1c2a935 100644
--- a/eris/Member.hpp
+++ b/eris/Member.hpp
@@ -10,6 +10,7 @@
 #include <type_traits>
 #include <algorithm>
 #include <string>
+#include <boost/type_traits/is_base_of.hpp>
 
 namespace eris {
 
@@ -287,7 +288,7 @@ class Member : private noncopyable {
                  * members.
                  */
                 template <class Container>
-                typename std::enable_if<std::is_base_of<Member, typename Container::value_type::member_type>::value, Lock
+                typename std::enable_if<boost::is_base_of<Member, typename Container::value_type::member_type>::value, Lock
                 >::type remove(const Container &members) {
                     if (members.empty()) return Lock(isWrite(), isLocked()); // Fake lock
 
@@ -428,7 +429,7 @@ class Member : private noncopyable {
         template <class Container>
         [[gnu::warn_unused_result]] Lock writeLock(const Container &plus,
                 typename std::enable_if<
-                    std::is_base_of<Member, typename Container::value_type::member_type>::value
+                    boost::is_base_of<Member, typename Container::value_type::member_type>::value
                 >::type* = 0) const {
             return rwLock_(true, plus);
         }
@@ -547,7 +548,7 @@ class Member : private noncopyable {
         template <class Container>
         Lock rwLock_(const bool &write, const Container &plus,
                 typename std::enable_if<
-                    std::is_base_of<Member, typename Container::value_type::member_type>::value
+                    boost::is_base_of<Member, typename Container::value_type::member_type>::value
                 >::type* = 0) const {
             const bool has_sim = hasSimulation();
             if (has_sim and maxThreads() == 0) return Member::Lock(write); // Fake lock
diff --git a/eris/SharedMember.hpp b/eris/SharedMember.hpp
index 6ef243f..da0245f 100644
--- a/eris/SharedMember.hpp
+++ b/eris/SharedMember.hpp
@@ -5,6 +5,7 @@
 #include <typeinfo>
 #include <functional>
 #include <type_traits>
+#include <boost/type_traits/is_base_of.hpp>
 
 namespace eris {
 
@@ -99,7 +100,7 @@ class SharedMember final {
          */
         template<class F>
         SharedMember(const SharedMember<F> &from,
-                typename std::enable_if<std::is_base_of<T, F>::value and not std::is_same<T, F>::value>::type* = 0)
+                typename std::enable_if<boost::is_base_of<T, F>::value and not std::is_same<T, F>::value>::type* = 0)
             : ptr_{std::static_pointer_cast<T,F>(from.ptr())}
         {}
 
@@ -115,7 +116,7 @@ class SharedMember final {
          */
         template<class F>
         SharedMember(const SharedMember<F> &from,
-                typename std::enable_if<std::is_base_of<F, T>::value and not std::is_same<T, F>::value>::type* = 0)
+                typename std::enable_if<boost::is_base_of<F, T>::value and not std::is_same<T, F>::value>::type* = 0)
             : ptr_{std::dynamic_pointer_cast<T,F>(from.ptr())} {
             // Raise an exception if the ptr above gave back a null shared pointer: that means the
             // cast attempted to cast to a derived class, when the actual object is only a base
diff --git a/eris/Simulation.hpp b/eris/Simulation.hpp
index 5786d95..01f6126 100644
--- a/eris/Simulation.hpp
+++ b/eris/Simulation.hpp
@@ -19,6 +19,7 @@
 #include <atomic>
 #include <condition_variable>
 #include <mutex>
+#include <boost/type_traits/is_base_of.hpp>
 
 /// Base namespace containing all eris classes.
 namespace eris {
@@ -61,27 +62,27 @@ class Simulation final : public std::enable_shared_from_this<Simulation>, privat
         /** Accesses an agent given the agent's eris_id_t.  Templated to allow conversion to
          * a SharedMember of the given Agent subclass; defaults to Agent.
          */
-        template <class A = Agent, typename = typename std::enable_if<std::is_base_of<Agent, A>::value>::type>
+        template <class A = Agent, typename = typename std::enable_if<boost::is_base_of<Agent, A>::value>::type>
         SharedMember<A> agent(eris_id_t aid) const;
         /** Accesses a good given the good's eris_id_t.  Templated to allow conversion to a
          * SharedMember of the given Good subclass; defaults to Good.
          */
-        template <class G = Good, typename = typename std::enable_if<std::is_base_of<Good, G>::value>::type>
+        template <class G = Good, typename = typename std::enable_if<boost::is_base_of<Good, G>::value>::type>
         SharedMember<G> good(eris_id_t gid) const;
         /** Accesses a market given the market's eris_id_t.  Templated to allow conversion to a
          * SharedMember of the given Market subclass; defaults to Market.
          */
-        template <class M = Market, typename = typename std::enable_if<std::is_base_of<Market, M>::value>::type>
+        template <class M = Market, typename = typename std::enable_if<boost::is_base_of<Market, M>::value>::type>
         SharedMember<M> market(eris_id_t mid) const;
         /** Accesses a non-agent/good/market member that has been added to this simulation.  This is
          * typically an optimization object.
          */
         template <class O = Member, typename = typename std::enable_if<
-            std::is_base_of<Member, O>::value
+            boost::is_base_of<Member, O>::value
             and not (
-                    std::is_base_of<Agent, O>::value or
-                    std::is_base_of<Good, O>::value or
-                    std::is_base_of<Market, O>::value)
+                    boost::is_base_of<Agent, O>::value or
+                    boost::is_base_of<Good, O>::value or
+                    boost::is_base_of<Market, O>::value)
             >::type>
         SharedMember<O> other(eris_id_t oid) const;
 
@@ -111,7 +112,7 @@ class Simulation final : public std::enable_shared_from_this<Simulation>, privat
          *     auto good = sim->spawn<Good::Continuous>("x");
          *     auto market = sim->spawn<Bertrand>(Bundle(good, 1), Bundle(money, 1));
          */
-        template <class T, typename... Args, class = typename std::enable_if<std::is_base_of<Member, T>::value>::type>
+        template <class T, typename... Args, class = typename std::enable_if<boost::is_base_of<Member, T>::value>::type>
         SharedMember<T> spawn(Args&&... args);
 
         /** Old version of spawn<T>().
@@ -146,7 +147,7 @@ class Simulation final : public std::enable_shared_from_this<Simulation>, privat
          * small subset of the overall set of agents.  The cache is invalidated when any agent (of
          * any type) is added or removed.
          */
-        template <class A = Agent, typename = typename std::enable_if<std::is_base_of<Agent, A>::value>::type>
+        template <class A = Agent, typename = typename std::enable_if<boost::is_base_of<Agent, A>::value>::type>
         std::vector<SharedMember<A>> agents(const std::function<bool(const A &agent)> &filter = nullptr) const;
         /** Provides a count of matching simulation agents.  Agents are filtered by class and/or
          * callable filter and the count of matching agents is returned.  This is equivalent to
@@ -155,7 +156,7 @@ class Simulation final : public std::enable_shared_from_this<Simulation>, privat
          * Note that this method populates and uses the same cache as agents() when `A` is not the
          * default `Agent` class.
          */
-        template <class A = Agent, typename = typename std::enable_if<std::is_base_of<Agent, A>::value>::type>
+        template <class A = Agent, typename = typename std::enable_if<boost::is_base_of<Agent, A>::value>::type>
         size_t countAgents(const std::function<bool(const A &agent)> &filter = nullptr) const;
 
         /** Provides a filtered vector of simulation goods.  This works just like agents(), but for
@@ -163,13 +164,13 @@ class Simulation final : public std::enable_shared_from_this<Simulation>, privat
          *
          * \sa agents()
          */
-        template <class G = Good, typename = typename std::enable_if<std::is_base_of<Good, G>::value>::type>
+        template <class G = Good, typename = typename std::enable_if<boost::is_base_of<Good, G>::value>::type>
         std::vector<SharedMember<G>> goods(const std::function<bool(const G &good)> &filter = nullptr) const;
         /** Provides a count of matching simulation goods.  Goods are filtered by class and/or
          * callable filter and the count of matching goods is returned.  This is equivalent to
          * goods<G>(filter).size(), but more efficient.
          */
-        template <class G = Good, typename = typename std::enable_if<std::is_base_of<Good, G>::value>::type>
+        template <class G = Good, typename = typename std::enable_if<boost::is_base_of<Good, G>::value>::type>
         size_t countGoods(const std::function<bool(const G &good)> &filter = nullptr) const;
 
         /** Provides a filtered vector of simulation markets.  This works just like agents(), but
@@ -177,13 +178,13 @@ class Simulation final : public std::enable_shared_from_this<Simulation>, privat
          *
          * \sa agents()
          */
-        template <class M = Market, typename = typename std::enable_if<std::is_base_of<Market, M>::value>::type>
+        template <class M = Market, typename = typename std::enable_if<boost::is_base_of<Market, M>::value>::type>
         std::vector<SharedMember<M>> markets(const std::function<bool(const M &market)> &filter = nullptr) const;
         /** Provides a count of matching simulation markets.  Markets are filtered by class and/or
          * callable filter and the count of matching markets is returned.  This is equivalent to
          * markets<G>(filter).size(), but more efficient.
          */
-        template <class M = Market, typename = typename std::enable_if<std::is_base_of<Market, M>::value>::type>
+        template <class M = Market, typename = typename std::enable_if<boost::is_base_of<Market, M>::value>::type>
         size_t countMarkets(const std::function<bool(const M &good)> &filter = nullptr) const;
 
         /** Provides a filtered vector of non-agent/good/market simulation objects.  This works just like
@@ -192,7 +193,7 @@ class Simulation final : public std::enable_shared_from_this<Simulation>, privat
          * \sa agentFilter
          */
         template <class O = Member, typename = typename std::enable_if<
-            std::is_base_of<Member, O>::value and not std::is_base_of<Agent, O>::value and not std::is_base_of<Market, O>::value
+            boost::is_base_of<Member, O>::value and not boost::is_base_of<Agent, O>::value and not boost::is_base_of<Market, O>::value
             >::type>
         std::vector<SharedMember<O>> others(const std::function<bool(const O &other)> &filter = nullptr) const;
         /** Provides a count of matching simulation non-agent/good/market members.  Members are
@@ -200,7 +201,7 @@ class Simulation final : public std::enable_shared_from_this<Simulation>, privat
          * This is equivalent to members<G>(filter).size(), but more efficient.
          */
         template <class O = Member, typename = typename std::enable_if<
-            std::is_base_of<Member, O>::value and not std::is_base_of<Agent, O>::value and not std::is_base_of<Market, O>::value
+            boost::is_base_of<Member, O>::value and not boost::is_base_of<Agent, O>::value and not boost::is_base_of<Market, O>::value
             >::type>
         size_t countOthers(const std::function<bool(const O &good)> &filter = nullptr) const;
 
diff --git a/eris/algorithms.hpp b/eris/algorithms.hpp
index 4aebadb..c8d1d48 100644
--- a/eris/algorithms.hpp
+++ b/eris/algorithms.hpp
@@ -6,6 +6,7 @@
 #include <vector>
 #include <limits>
 #include <utility>
+#include <boost/type_traits/is_base_of.hpp>
 
 namespace eris {
 
@@ -37,7 +38,7 @@ namespace eris {
  *        will be in the same order as encountered in the input iterator.
  */
 template <typename It>
-typename std::enable_if<std::is_base_of<std::forward_iterator_tag, typename std::iterator_traits<It>::iterator_category>::value>::type
+typename std::enable_if<boost::is_base_of<std::forward_iterator_tag, typename std::iterator_traits<It>::iterator_category>::value>::type
 all_combinations(
             const It &begin,
             const It &end,
@@ -102,7 +103,7 @@ all_combinations(
 template <class BidirIt>
 typename std::enable_if<
     std::is_integral<typename BidirIt::value_type>::value and
-    std::is_base_of<std::bidirectional_iterator_tag, typename std::iterator_traits<BidirIt>::iterator_category>::value
+    boost::is_base_of<std::bidirectional_iterator_tag, typename std::iterator_traits<BidirIt>::iterator_category>::value
 , bool>::type
 next_increasing_integer_permutation(BidirIt first, BidirIt last, typename BidirIt::value_type max) {
     auto it = last;
