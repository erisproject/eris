(TODO: make this into proper documentation)

This document covers the coding guidelines to be used in Eris code.  Not all
classes currently conform to this, but all new code should.

This document is neither exhaustive nor absolute.  Minor violations may be
acceptable if they have a good rationale behind them.


Naming conventions for variables/classes/etc.
=============================================
- Class names should start with a capital letter.  If consisting of multiple
  words, the first letter of each word should be capitalized with no
  underscore between words.  Example: `Awesome`, `MyClass`, but not
  `someClass` or `That_Class`.

- namespaces should be lower-case and usually in the `eris` namespace or a
  namespace nested within `eris` (e.g. `eris::firm`).

- Structs should always be declared in lower case with underscores separating
  words, such as `some_struct` or `blah`.

- Methods should start with a lower-case letter, with upper-case letters used
  to distinguish words and no underscores, such as `meth` or `myMethod`.

- Public member variables should be lower-case, with underscores separating
  words, such as `foo` or `some_value`.

- Private and protected member variables should be lower-case with underscores
  separating words, and followed by an underscore, such as `foo_` or
  `some_value_`.

- Local variables should be named in the same way as public member variables.


Directory and source filename structure
=======================================
- Library headers live in `include/eris`, source files live in `src`.

- Headers for C++ code use a .hpp extension.  Only if a header is pure C code
  may .h be used.

- Header file hierarchy should follow the C++ namespace hierarchy.  For
  example, class eris::ClassName belongs in `include/eris/ClassName.hpp`;
  eris::firm::Magical belongs in `include/eris/firm/Magical.hpp`.

- Headers for classes are generally stored in a header file with the same name
  as the class, such as `eris::ClassName` being defined in
  `eris/ClassName.hpp`.  Some exceptions for tightly related classes are
  acceptable: for example, `eris/Bundle.hpp` defines both `Bundle` and
  `BundleNegative` classes; `eris/Firm.hpp` has both `Firm` and `FirmNoProd`
  classes; and `eris/Member.hpp` defines both `Member` and its `SharedMember`
  wrapper.

- Header files beginning with a lower-case letter are used for collections of
  small classes or definitions.  For example, the `eris_id_t` typedef is
  defined in eris/types.hpp, and a few small algorithm classes are in
  `eris/algorithms.hpp`.

- Source files associated with headers go under `src/`, and should have
  exactly the same name as the header file, but without the leading `eris/`
  directory, and with the `.cpp` extension instead of `.hpp`.  (`.c` is
  acceptable for pure-C classes).


Documentation
=============
Eris uses doxygen for API documentation.  Rules to follow when adding doxygen
documentation:

- Every public and protected member should be documented with
  doxygen-compatible comments.

- Comments should be useful enough for someone to understand the interface and
  purpose of a function or variable (for public members), and useful enough
  for a subclass writer to make use of the member (for protected members).

- Multi-line comments should be formatted using `/** ... */` comments, in the
  following style:

      /** Comment starts here and
       * continues here.
       *
       * More comments.
       *
       * \param blah description of parameter
       */
      void foo(int blah);

- Single-line comments may use either `/** ... */` comments, or `/// ...`
  comments. `/// ...` should *not* be used for multi-line comments.

- Namespaces should be documented in an appropriate and logical place.  If
  classes in a given namespace typically have a common base class, the base
  class should contain the namespace documentation (for example,
  `eris/Firm.hpp` documents the `eris::firm` namespace).

- All documentation should be in the .hpp header files.  The .cpp source files
  should contain code comments as needed to help in following the source code,
  but *documentation* belongs in the header files.


General code guidelines
=======================

- Headers:
  - Every header should begin with `#pragma once` (rather than an explicit
    include guard).

  - Eris library code should use angle-bracket includes rather than quoted
    includes, i.e. <path/name.hpp> instead of "path/name.hpp".

  - Use inline functions only when they are small and frequently called, and
    have relatively simple logic.

  - Use as few #includes as possible.  Consider using forward declarations of
    classes when practical (they may be required to break cyclical
    dependencies).  #includes in a header should only be used for code
    declared in the header itself; if the include is only needed for the .cpp
    source code, the include belongs in the .cpp file.

- Scoping:
  - Use the narrowest scope possible, and initialize variables during
    declaration where feasible.

- Classes:
  - Minimize work in constructors.
  - Single-argument constructors should usually be declared explicit, to avoid
    implicit type conversion.  If a single-argument constructor is purposely
    not explicit (for example, wrapper classes or copy constructors), it
    should be (briefly) documented.
  - Classes should always be declared with the `class` operator; a `struct`
    should only be used as a passive container.
  - Don't use private inheritance.  Usually private inheritance is better
    served by storing the private class instance as a private member object
    instead.
  - Don't use operator overloading unless such overloading is immediately
    obvious and natural to users of the class.  Bundle uses it extensively,
    since operations like adding two bundles together makes immediate sense.
    Most classes don't have such a natural interpretation.

- C++ language features:
  - Eris is C++11 code; any standard c++11 features are acceptable.
  - use `auto` to avoid pointlessly cluttered type names (especially for
    templated type names).


Code formatting
===============
- 4-space indent.  No tabs.
- Aim for 100-character wide code.  Some code may exceed this, slightly, if
  wrapping would be ugly.  Documentation comments should always be wrapped at
  100 characters (because any decent editor makes this easy), unless strictly
  needed (for example, for a code example).
- Opening braces should be at the end of a line, not on their own line.
- Closing braces should line up, either vertically or horizontally, with the
  first character that started the block.  For example:
      if (blah) {
          ...
      }
      else if (blah2) { ... }
- Don't "cuddle" elses: the 'else' keyword should start the line.
- Spaces around operators and comparisons, e.g. `a + b` and `a == b` rather
  than `a+b` and `a==b`.
- Pad the outside, not the inside, of parentheses (EXCEPT for parentheses used
  for a function call, see below).  e.g. `(a + b) * 3` and `if (a >= b) { ...
  }` rather than `( a + b )*3` or `if(a >= b) { ... }` or `if (a >= b){ ...
  }`.
- Don't-pad-inside takes precedence for nested parentheses, e.g. `((a + b) *
  3)` should be used instead of `( (a + b) * 3)`.
- Never put a space between a function call and the opening parenthesis for
  its arguments.  e.g. `func(a, b)`, not `func (a, b)`.
- No spaces around pointer and reference expressions.  e.g. `*p`, `&r`,
  `p->a`, `r.a`.
- Declarations of pointers and references should attach the `*` or `&` to the
  variable, not the type.  e.g. `char *c` not `char* c`.  This is particularly
  important when declaring multiple variables, since the prohibited `char* a,
  b, c` would declare b and c as chars, rather than char*'s.
- Function/method arguments should either be all on one line, or listed one
  per line, indented, beginning on a new line (or both).  For multi-line
  function declarations, the closing parenthesis may be on the same line as
  the last argument, or on its own line, lined up with either the arguments or
  the opening declaration.  e.g.
      bool f1(int a, double b, double c) {

      bool f2(
          int a, double b, double c) {

      bool f3(
          int a,
          double b,
          double c) {

      bool f4(
          int a,
          double b,
          double c
          ) {
      
      bool f5(
          int a,
          double b,
          double c
      ) {
  are all acceptable, while the following are not:
      bool f5(
          int a, double b,
          double c) {

      bool f6(
      int a,
      double b,
      double c) {
- Do not indent namespaces.
- When all the code in a file is inside a nested namespace, declare the
  namespace on the same line, e.g. `namespace one { namespace two {`.  (and
  don't indent), and close the namespaces a `} }` (or `}}`) at the end of the
  file.
